---
title: ^ConcurrentHashMap
---

## 概述

ConcurrentHashMap（后续文章用Cmap代替）, 作为 `java.util.concurrent` 包的重要组成, 解决了：

- HashMap的线程不安全因素: jdk1.7中处理hash冲突时, 会将元素放在entry链式结构的首位, 多线程情况下回生成环 (`成环的步骤未知晓，待补充`);
- HashTable的并发性能瓶颈: HashTable在处理并发的时候是将整个Hash数组上锁, Cmap采用了 分段加锁(jdk1.7)/sizeCtl+CAS+sychronized(jdk1.8) 的方式来增加并发写的能力。

## 结构

> Jdk 1.7

- CMap在jdk1.7采用的是分段锁实现并发控制，并发理论最大值为Segment数量。剩下的部分仍然是数组+链表的情况。
**（在多线程共同对不同的segment进行写操作时，由于jdk1.7对Segment进行sychronized加锁，所以多线程操作同一个Segement的写操作时候，仍然需要等待。但是读使用CAS，不上锁）**

> Jdk 1.8

- CMap在Jdk1.7中虽然没有HashTable那样整个hash表上锁，但是仍然存在比较严重的并发缺陷，(_而且Segment一经初始化不可扩张？_)

- 在Jdk1.8中，引入了sizeCtl这一属性，外加CAS+Sychronized对Entry数组的Head头指针双重控制，Cmap的理论并发最大值变为了Entry数组的最大值。且由于协同扩容的概念存在，多线程操作的情况可以加速扩容操作(当entry数组长度 < `sizeCtl -1`的时候，新晋线程会加入到扩容操作中，并通过相同的标识方式告知其他线程当前节点已经有线程在操作了)。

- 在Jdk1.8中，结构不再是数组+链表的形式，而是在链表的长度大于`8`的时候，修正链表的结构为红黑树，加快存在hash冲突的Entry数据的遍历检索，同时，当扩容导致数据的红黑树节点数量减少时（扩容的reHash会导致`链式结构/树式结构`中，n位｛n为数组长度的2^n幂数｝为1的数据被分离到新扩容的位置的对应下标处），如果树式结构不能满足6个节点的情况，那么将不再维持树形结构而转为链表形式存储（数据不足的情况下，维护树的结构是一种额外的开销）

## size的计算

> Jdk 1.7

Cmap在Jdk1.7中计算size的方式有些参考了 `乐观` 的思想，它会通过size的方式计算两次size，如果计算的结果相同则会返回。如果计算的结果不同就会进行加锁计算。

> Jdk 1.8

Cmap在Jdk1.8中引入了CAS操作，size读取数据时为CAS进行，但是CAS存在失败的情况。于是加入了`失败数组`的概念(_具体变量名不记得了，暂时先这么叫着_)，如果CAS操作失败了，就在数组中记录。最后的结果size = casSize + countSize[] (_这里有2个问题：1.这个数组里面存的值是直到生效吗？2.这个数组的值是怎么计算的？CAS失败的时候是把CAS操作的哪个数据加进去了？_)
